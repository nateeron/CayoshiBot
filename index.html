<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lightweight Charts with Binance WebSocket Data</title>
    <script
        src="https://cdn.jsdelivr.net/npm/lightweight-charts@3.6.0/dist/lightweight-charts.standalone.production.js"></script>
    <script src="https://unpkg.com/lightweight-charts/dist/lightweight-charts.standalone.production.js"></script>

</head>

<body>
    <style>
        #chart1 {
            width: 100%;
            height: 80vh;
        }

        body {
            color: aliceblue;

            background-color: #222;
        }

        .tradingview-widget-container {
            height: 60vh !important;
        }

        .custom-tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 5px 10px;
            border-radius: 4px;
            font-family: Arial, sans-serif;
            font-size: 12px;
            display: none;
        }
    </style>
    <div>
        <label for="timeframe">Select Timeframe:</label>
        <select id="timeframe">
            <option value="1m">1 Minute</option>
            <option value="15m">15 Minutes</option>
            <option value="30m">30 Minutes</option>
            <option value="1h">1 Hour</option>
            <option value="2h">2 Hours</option>
            <option value="4h">4 Hours</option>
            <option value="1d">1 Day</option>
        </select>
    </div>
    <div id="chart1"></div>

    <div class="custom-tooltip" id="custom-tooltip"></div>
    <script>
        const myPriceFormatter = p => p.toFixed(4);
        //----------------------------------------------------------
        //const currentLocale = window.navigator.languages[0];
        //// Create a number format using Intl.NumberFormat
        //const myPriceFormatter = Intl.NumberFormat(currentLocale, {
        //    style: 'currency',
        //    currency: 'EUR', // Currency for data points
        //}).format;
        //----------------------------------------------------------
        const symbo = 'XRPUSDT'
        const TimeFream = '1m'
        //**************************************************************************************
        // [Chart Options]
        //**************************************************************************************
        const chartOptions = {
            layout: {
                textColor: '#E4E4E4',
                background: { type: 'solid', color: '#202020' },
                borderColor: '#63C20B',
            },
            timeScale: {
                timeVisible: true,
                secondsVisible: false,
                tickMarkFormatter: (time, tickMarkType, locale) => {

                    // Convert seconds to milliseconds
                    const utcDate = new Date(time * 1000);

                    // Add 7 hours for Bangkok timezone (UTC+7)
                    const bangkokTime = new Date(utcDate.getTime() - (7 * 60 * 60 * 1000));

                    // Format Bangkok time as desired
                    const formattedTime = bangkokTime.toLocaleString('en-US', {
                        day: 'numeric',
                        month: 'short',
                        year: 'numeric',
                        hour: '2-digit',
                        minute: '2-digit',
                        hour12: false, // Use 24-hour format
                    });

                    return formattedTime;
                },
            },
            // set Color the grid lines
            // grid: {
            //     vertLines: { color: '#444' },
            //     horzLines: { color: '#444' },
            // },
            // hide the grid lines
            grid: {
                vertLines: {
                    visible: false,
                },
                horzLines: {
                    visible: false,
                },
            }, localization: {
                priceFormatter: myPriceFormatter,
            },
        };


        const container = document.getElementById('chart1');
        const chart = LightweightCharts.createChart(container, chartOptions);

        const candlestickSeries = chart.addCandlestickSeries({
            upColor: '#26a69a',
            downColor: '#ef5350',
            borderVisible: false,
            wickUpColor: '#26a69a',
            wickDownColor: '#ef5350',
        });
        //*************************************************************************************
        // [ MA ]
        //*************************************************************************************
        let socket;
        let maSeries;
        let maSeries2;
        const maPeriod = 90;
        const maPeriod2 = 20;
        function updateMovingAverageSeries(candleData, period) {
            if (maSeries) {
                chart.removeSeries(maSeries);
            }
            const maData = calculateMovingAverageSeriesData(candleData, period);
            maSeries = chart.addLineSeries({ color: '#CA7B05', lineWidth: 1 });
            maSeries.setData(maData);
        }

        function updateMovingAverageSeries2(candleData, period) {
            if (maSeries2) {
                chart.removeSeries(maSeries2);
            }
            const maData = calculateMovingAverageSeriesData(candleData, period);
            maSeries2 = chart.addLineSeries({ color: '#69B90D', lineWidth: 1 });
            maSeries2.setData(maData);
        }
        const decimal = 4

        //*************************************************************************************
        // Function
        //*************************************************************************************

        function formatPrice(value, decimals) {
            return Number(value.toFixed(decimals));
        }
        function CheckTimelineData(data) {
            let t1 = data[0].timestamp;
            let t2 = data[1].timestamp;
            if (t1 < t2) return true;
            return false;
        }

        function calculateMovingAverageSeriesData(candleData, maLength) {
            const maData = [];

            for (let i = 0; i < candleData.length; i++) {
                if (i < maLength) {
                    // Provide whitespace data points until the MA can be calculated
                    maData.push({ time: candleData[i].time });
                } else {
                    // Calculate the moving average, slow but simple way
                    let sum = 0;
                    for (let j = 0; j < maLength; j++) {
                        sum += candleData[i - j].close;
                    }
                    const maValue = sum / maLength;
                    maData.push({ time: candleData[i].time, value: maValue });
                }
            }

            return maData;
        }

        function StartNewTime(interval, factor) {
            // Define the number of seconds per interval unit
            const intervalUnits = {
                's': 1,            // Seconds
                'm': 60,           // Minutes
                'h': 3600,         // Hours
                'd': 86400,        // Days
                'w': 604800        // Weeks
            };

            // Parse the interval to get the number and the unit
            const intervalValue = parseInt(interval.slice(0, -1), 10);
            const intervalUnit = interval.slice(-1);
            //console.log(intervalValue, intervalUnit, intervalUnits[intervalUnit], factor)
            // Calculate the total number of seconds
            const totalSeconds = intervalValue * intervalUnits[intervalUnit] * factor * 1000;
            //console.log("totalSeconds", totalSeconds)



            return totalSeconds;
        }

        function validateData(data) {
            return data.filter(item => item !== null && item !== undefined);
        }

        function removeDuplicates(data) {
            const seen = new Set();
            //const resp = data.filter(item => {
            //   console.log(item.timestamp);
            //});
            const resp = data.filter(item => {
                const duplicate = seen.has(item.timestamp);
                seen.add(item.timestamp);
                return !duplicate;
            });
            return resp
        }

        function SortData(data) {
            // Sort the filtered data by time in ascending order
            const sortedData = data.sort((a, b) => a.timestamp - b.timestamp);
            //const sortedData = data.sort((a, b) => {
            //    console.log(a.timestamp);
            //});
            return sortedData;
        }
        //*************************************************************************************
        // Call API [Post] 'http://127.0.0.1:45441/infoPrice/getprice'
        //*************************************************************************************
        /*Data Post {
                "symbol":"XRPUSDT",
                "tf":"1m",
                "getAll": false,
                "datefrom":"10-02-2025",
                "dateto":"10-03-2025",
                "ohcl":"c"
            }*/
        //*************************************************************************************
        // Call API [Post] 'http://127.0.0.1:45441/infoPrice/getprice'
        //*************************************************************************************
        async function fetchData(req, path) {
            console.log(req)
            // Create the data to send in the POST request
            const urldata = 'http://127.0.0.1:45441/infoPrice/' + path
            const requestData = {
                symbol: symbo,
                tf: TimeFream,
                getAll: false,
                datefrom: req.Time_min,
                dateto: req.Time_max,
                ohlc: "ohlc",
                limit: 1000
            };
            console.log(requestData)

            // Send the POST request with JSON data
            const response = await fetch(urldata, {
                method: 'POST', // Use POST method
                headers: {
                    'Content-Type': 'application/json' // Set the content type to JSON
                },
                body: JSON.stringify(requestData) // Convert the JavaScript object to a JSON string
            });

            // Parse the response as JSON
            const data = await response.json();
            const isPass = CheckTimelineData(data)
            if (!isPass) {
                console.error("sort Timeline Data 0,1,2,3 ต้องจากน้อยไปมาก");
            }
            return data;
        }

        async function fetchData_MarkersBacktest(req, path) {
            console.log(req)
            // Create the data to send in the POST request
            //const urldata = 'http://127.0.0.1:45441/botgrid/data_Backtest'
            const urldata = 'http://127.0.0.1:45441/botgrid/' + path
            const requestData = {
                symbol: symbo,
                tf: TimeFream,
                DateFrom: req.start_time,
                limit: req.limit,

            };
            console.log(requestData)

            // Send the POST request with JSON data
            const response = await fetch(urldata, {
                method: 'POST', // Use POST method
                headers: {
                    'Content-Type': 'application/json' // Set the content type to JSON
                },
                body: JSON.stringify(requestData) // Convert the JavaScript object to a JSON string
            });

            // Parse the response as JSON
            const data = await response.json();
            const isPass = CheckTimelineData(data)
            if (!isPass) {
                console.error("sort Timeline Data 0,1,2,3 ต้องจากน้อยไปมาก");
            }
            return data;
        }
        async function fetch_dataBackTest(start_time, limit) {
            let allData = [];
            const req = {start_time:start_time, limit:limit};
            try {
                const getprice = "data_Backtest"
                const data = await fetchData_MarkersBacktest(req, getprice);

                return data;
            } catch {
                return null

            }
        }
        async function fetchAllKlines(Symbol, Interval, loadTime_min, loadTime_max, Limit) {
            let allData = [];
            const req = {
                symbol: Symbol, interval: Interval, Time_min: loadTime_min, Time_max: loadTime_max, limit: Limit
            }
            try {
                const getprice = "getprice_start"
                const data = await fetchData(req, getprice);
                allData = allData.concat(data);
                const resp = SortData(allData)
                const validData = validateData(resp);
                const noDuplicatesData = removeDuplicates(validData);

                return noDuplicatesData;
            } catch {
                return null

            }
        }

        async function fetchLoad_bar_lazy(Symbol, Interval, loadTime_min, loadTime_max, Limit) {
            let allData = [];
            const req = {
                symbol: Symbol, interval: Interval, Time_min: loadTime_min, Time_max: loadTime_max, limit: Limit
            }
            try {
                const getprice = "Load_bar_lazy"
                const data = await fetchData(req, getprice);
                allData = allData.concat(data);
                const resp = SortData(allData)
                const validData = validateData(resp);
                const noDuplicatesData = removeDuplicates(validData);

                return noDuplicatesData;
            } catch {
                return null

            }
        }
        //*************************************************************************************
        // [function 2]
        //*************************************************************************************
        function calbar_From_Time(start_time) {
            const offsetUTC7 = 7 * 60 * 60 * 1000;
            const startTime = new Date().getTime() + offsetUTC7;
            resp = (startTime - start_time) / 60000
            return Math.ceil(resp)
        }

        async function fetchData_LastReailTime(symbol, TF, start_timestamp) {
            // Create the data to send in the POST request
            const base_url = "https://api.binance.com/api/v3/klines";
            //const offsetUTC7 = 7 * 60 * 60 * 1000;
            //const startTime = new Date("2024-12-16 08:42:00").getTime() + offsetUTC7;
            //console.log('startTime', startTime)
            const limit = 1000;
            let start = start_timestamp + StartNewTime(TF, 1)
            const fetchCount = Math.ceil(calbar_From_Time(start) / limit)
            //หาจำนวนิฟพ ที่ Load จากเวลา
            let params = new URLSearchParams({
                symbol: symbol,
                interval: TF,
                limit: limit,
                startTime: start
            });
            let allData = [];
            const processedData = []
            //let fetchCount = Math.ceil(totalRows / limit);
            for (let i = 0; i < fetchCount; i++) {

                fetch(`${base_url}?${params.toString()}`)
                    .then(response => response.json())
                    .then(data => {
                        allData = allData.concat(data);
                        //const data = response.json();
                        //const response = await fetch(`${base_url}?${params.toString()}`);

                        // Check if the response is successful
                        //if (!response.ok) {
                        //    throw new Error('Failed to fetch data');
                        //}

                        // Parse the JSON response


                        // Process the data
                        // Process the fetched data and append to result

                        if (data.length > 0) {
                            const st = StartNewTime(TF, limit)
                            start = data[0].time - StartNewTime(TF, limit);
                        }

                        // }


                    }).catch(error => console.error('Error fetching data:', error));
            }
            const formattedData = allData.map(item => ({
                time: item[0] / 1000, // Convert to seconds
                open: parseFloat(item[1]),
                high: parseFloat(item[2]),
                low: parseFloat(item[3]),
                close: parseFloat(item[4])
            }));

            return formattedData;
        }


        //*************************************************************************************
        // [Start ]
        //*************************************************************************************
        let processedData = null
        let isLoading = false;
        let isLoading_s = false;
        let startTimestamp = null;
        let markers_backtest = null;
        // อ้างอิง : https://developers.binance.com/docs/binance-spot-api-docs/rest-api
        async function fetchHistoricalData(symbol, interval, limit) {

            const rawKlines = await fetchAllKlines(symbol, interval, "", "", 1000);

            try {
                const UTCBangkok = 7 * 60 * 60
                processedData = rawKlines.map(item => ({
                    time: Math.floor(item.timestamp / 1000 + UTCBangkok), // Convert milliseconds to seconds
                    open: parseFloat(item.open),
                    high: parseFloat(item.high),
                    low: parseFloat(item.low),
                    close: parseFloat(item.close)
                }));
                startTimestamp = processedData[0].time;
                console.log("******************************** Load Reailtime *****************************")
                console.log(processedData.length,startTimestamp)
                //********************************* Load Reailtime *********************************
                console.log(processedData)
                //close: 2.5194
                //high: 2.5219
                //low: 2.5188
                //open: 2.5214
                //time: 1734542280

                //const offsetUTC7 = 7 * 60 * 60 * 1000;
                //const timestamp = rawKlines[rawKlines.length - 1].timestamp;
                //const FromOutService = fetchData_LastReailTime(symbol, interval, timestamp)

                //// Create a Date object from the timestamp
                //const date = new Date(timestamp);


                //// Format the date components
                //const day = String(date.getUTCDate()).padStart(2, '0');
                //const month = String(date.getUTCMonth() + 1).padStart(2, '0'); // Months are zero-based
                //const year = date.getUTCFullYear();
                //const hours = String(date.getUTCHours()).padStart(2, '0');
                //const minutes = String(date.getUTCMinutes()).padStart(2, '0');
                //const seconds = String(date.getUTCSeconds()).padStart(2, '0');

                //// Combine to desired format
                //const formattedDate = `${day}-${month}-${year} ${hours}:${minutes}:${seconds}`;
                //********************************* END Load Reailtime *********************************


                //fetch(`${base_url}?${params.toString()}`)
                //    .then(response => response.json())
                //    .then(data => {
                //        processedData = data.map(item => ({
                //            time: item[0] / 1000, // Convert milliseconds to seconds
                //            open: formatPrice(parseFloat(item[1]), decimal),
                //            high: formatPrice(parseFloat(item[2]), decimal),
                //            low: formatPrice(parseFloat(item[3]), decimal),
                //            close: formatPrice(parseFloat(item[4]), decimal)
                //        }));
                //------ Start EMA20 -----------------
                // EMA 20

                //updateMovingAverageSeries(processedData, maPeriod);
                //updateMovingAverageSeries2(processedData, maPeriod2);
                //
                ////------end EMA20 -----------------
                //
                //// add data
                candlestickSeries.setData(processedData);


                //------ markers arrowUp arrowDown-----------------
                const DATA_Backtest = await fetch_dataBackTest(startTimestamp,1000);
                console.log("DATA_Backtest")
                console.log(DATA_Backtest)
                //SeriesMarkerPosition: "aboveBar" | "belowBar" | "inBar"
                //SeriesMarkerShape: "circle" | "square" | "arrowUp" | "arrowDown"
                //const markers_backtest = DATA_Backtest.flatMap(item => [
                //    {
                //        time: Math.floor(item.timestem_buy / 1000), // Convert to seconds if needed
                //        position: 'belowBar',
                //        color: '#2A60C4',
                //        shape: 'arrowUp',
                //        text: `Buy @ ${item.priceAction}`
                //    },
                //    {
                //        time: Math.floor(item.timestem_sell / 1000), // Convert to seconds if needed
                //        position: 'aboveBar',
                //        color: '#D753E9FF',
                //        shape: 'arrowDown',
                //        text: `Sell @ ${item.priceSell}`
                //    }
                //]);
                const size = 1
                let sell_Multi = []
                if(DATA_Backtest){
                markers_backtest = DATA_Backtest.flatMap(item => {
                    const matchingItems = sell_Multi.filter(x => x === item.timestem_sell); // Check if timestem_sell exists in sell_Multi
                    let mess = "";
                    if (matchingItems.length > 0) {
                        console.log("*****************************************")
                        console.log(matchingItems)
                        if (matchingItems.length > 1) {
                            mess = "> X" + (matchingItems.length + 1).toString(); // Use sell_Multi.length instead of ss.length()
                        }
                        else if (matchingItems.length == 2) {
                            mess = ">> X" + (matchingItems.length + 1).toString(); // Use sell_Multi.length instead of ss.length()
                        } else if (matchingItems.length == 3) {
                            mess = ">>> X" + (matchingItems.length + 1).toString(); // Use sell_Multi.length instead of ss.length()

                        } else if (matchingItems.length ==4) {
                            mess = ">>>> X" + (matchingItems.length + 1).toString(); // Use sell_Multi.length instead of ss.length()

                        } else if (matchingItems.length == 5) {
                            mess = ">>>>> X" + (matchingItems.length + 1).toString(); // Use sell_Multi.length instead of ss.length()

                        } else if (matchingItems.length == 6) {

                            mess = ">>>>> X" + (matchingItems.length + 1).toString(); // Use sell_Multi.length instead of ss.length()
                        }else{
                            mess = ">>>>>> X" + (matchingItems.length + 1).toString(); // Use sell_Multi.length instead of ss.length()

                        }
                    }
                    if (item.status == 0) {
                        return [
                            {
                                time: Math.floor(item.timestem_buy / 1000 + UTCBangkok), // Convert to seconds if needed
                                position: 'belowBar',
                                color: '#4A9FE6FF',
                                shape: 'arrowUp',
                                text: `Buy @ ${item.priceAction}`,
                                size: size
                            }
                        ];
                    } else {
                        sell_Multi.push(item.timestem_sell);
                        return [
                            {
                                time: Math.floor(item.timestem_buy / 1000 + UTCBangkok), // Convert to seconds if needed
                                position: 'belowBar',
                                color: '#4A9FE6FF',
                                shape: 'arrowUp',
                                text: `Buy @ ${item.priceAction}`,
                                size: size
                            },
                            {
                                time: Math.floor(item.timestem_sell / 1000 + UTCBangkok), // Convert to seconds if needed
                                position: 'aboveBar',
                                color: '#DA46EEFF',
                                background: '#EEEEEEFF',
                                shape: 'arrowDown',
                                text: `Sell @ ${item.priceSell}  ${mess}`,
                                size: size
                            }
                        ];
                    }
                });
                if (markers_backtest.length > 0) {
                    candlestickSeries.setMarkers(markers_backtest);
                    }
            }
              
                // Add a horizontal line at price level 110
                console.log("1111111111")
                runRealtimeUpdates(symbol, interval);
                console.log("22222222222")

                chart.timeScale().subscribeVisibleLogicalRangeChange(onVisibleRangeChanged);
                console.log("3333333")

            } catch (Error) {
                console.error("Error",Error)

            }
        }

        function onVisibleRangeChanged(newLogicalRange) {
            const visibleRange = chart.timeScale().getVisibleLogicalRange();
            if (!visibleRange) return;

            const barsInfo = candlestickSeries.barsInLogicalRange(visibleRange);
            if (barsInfo && barsInfo.barsBefore < -20 && !isLoading_s) {
                console.log("Loading more bars...");
                loadMoreBars(symbo, TimeFream); // Adjust symbol and interval as necessary
                isLoading_s = false
                //setTimeout(() => {
                //    
                //}, 2*1000);
            }
            if(markers_backtest){

                candlestickSeries.setMarkers(markers_backtest);
            }
            chart.timeScale().getVisibleLogicalRange();
        }

        function formatTimestamp(timestamp) {
            // Convert the Unix timestamp to milliseconds
            const date = new Date(timestamp * 1000);
            const timezoneOffset = 7
            // Adjust for the timezone offset
            //const localDate = new Date(date.getTime() + timezoneOffset * 60 * 60 * 1000);
            //const localDate = new Date(date.getTime()-timezoneOffset * 60 * 60 * 1000);
            const localDate = new Date(date.getTime() - timezoneOffset * 60 * 60 * 1000);

            // Format the date and time components
            const year = localDate.getUTCFullYear();
            const month = String(localDate.getUTCMonth() + 1).padStart(2, '0'); // Months are 0-based
            const day = String(localDate.getUTCDate()).padStart(2, '0');
            const hours = String(localDate.getUTCHours()).padStart(2, '0');
            const minutes = String(localDate.getUTCMinutes()).padStart(2, '0');
            const seconds = String(localDate.getUTCSeconds()).padStart(2, '0');

            // Construct the formatted date string
            return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
        }

        async function loadMoreBars(symbol, interval) {
            if (isLoading || !startTimestamp) return; // Prevent multiple calls

            isLoading = true;
            isLoading_s = false
            try {
                const UTCBangkok = 7 * 60 * 60;

                // Fetch additional 1000 bars before the current startTimestamp
                const loadBar = (10000 * 60)
                const loadTime_max = formatTimestamp(startTimestamp - 60 + UTCBangkok)
                const loadTime_min = formatTimestamp(startTimestamp - loadBar + UTCBangkok)
                console.log(symbol, interval, loadTime_min, loadTime_max, 1000)
                const additionalKlines = await fetchLoad_bar_lazy(symbol, interval, loadTime_min, loadTime_max, 1000);
                console.log("additionalKlines", additionalKlines)

                if (additionalKlines && additionalKlines.length > 0) {

                    const moreData = additionalKlines.map(item => ({
                        time: Math.floor(item.timestamp / 1000 + UTCBangkok), // Convert milliseconds to seconds
                        open: parseFloat(item.open),
                        high: parseFloat(item.high),
                        low: parseFloat(item.low),
                        close: parseFloat(item.close)
                    }));

                    // Add new data to the beginning of the current data
                    processedData = [...moreData, ...processedData];
                    candlestickSeries.setData(processedData); // Update the chart
                    console.log("processedData", processedData)

                    // Update the startTimestamp
                    startTimestamp = moreData[0].time;
                }
            } catch (error) {
                console.error("Error loading more bars:", error);
            } finally {
                isLoading = false;
            }
        }

        function runRealtimeUpdates(symbol, interval) {
            if (socket) {
                socket.close();
            }

            // Get Price Reailtime
            socket = new WebSocket(`wss://stream.binance.com:9443/ws/${symbol.toLowerCase()}@kline_${interval}`);

            socket.onmessage = function (event) {
                const message = JSON.parse(event.data);
                const utcBangkok = 7 * 60 * 60
                const candle = {
                    time: message.k.t / 1000 + utcBangkok,  // Convert milliseconds to seconds
                    open: parseFloat(message.k.o),
                    high: parseFloat(message.k.h),
                    low: parseFloat(message.k.l),
                    close: parseFloat(message.k.c),
                };
                candlestickSeries.update(candle);
                //------ Start EMA20 -----------------
                // EMA 20
                const data = candlestickSeries.data();
                updateMovingAverageSeries(data, maPeriod);
                updateMovingAverageSeries2(data, maPeriod2);
                //------end EMA20 -----------------
            };
        }

        let interval;
        let symbolName = 'XRPUSDT TF: 1m';

        document.getElementById('timeframe').addEventListener('change', (event) => {
            interval = event.target.value;
            symbolName = 'XRPUSDT TF: ' + interval
            fetchHistoricalData(symbo, interval, 3000);
        });

        const areaSeries = chart.addAreaSeries({
            topColor: '#2962FF',
            bottomColor: 'rgba(41, 98, 255, 0.28)',
            lineColor: '#2962FF',
            lineWidth: 2,
            crossHairMarkerVisible: false,
        });
        // start get data
        fetchHistoricalData(symbo, TimeFream, 3000);  // Default to 1 minute interval


        // ----------------------------------------------------------------------------------------------------------------------------------------------------------
        const legend = document.createElement('div');
        legend.style = `position: absolute; left: 12px; top: 100px; z-index: 1; font-size: 14px; font-family: sans-serif; line-height: 18px; font-weight: 300;`;
        container.appendChild(legend);

        const firstRow = document.createElement('div');
        firstRow.innerHTML = symbolName;
        firstRow.style.color = 'aliceblue';
        legend.appendChild(firstRow);

        //chart.subscribeCrosshairMove(param => {
        //    let priceFormatted = '';
        //    if (param.time) {
        //        const data = param.seriesData.get(areaSeries);
        //        const price = data.value !== undefined ? data.value : data.close;
        //        priceFormatted = price.toFixed(2);
        //    }
        //    firstRow.innerHTML = `${symbolName} <strong>${priceFormatted}</strong>`;
        //});
        // ----------------------------------------------------------------------------------------------------------------------------------------------------------

        chart.timeScale().fitContent();
        chart.timeScale().scrollToPosition(5);

        const lineWidth = 1;
        const minPriceLine = {
            price: 0.602,
            color: '#ef5350',
            lineWidth: lineWidth,
            lineStyle: 2, // LineStyle.Dashed
            axisLabelVisible: true,
            title: 'min price',
        };
        const avgPriceLine = {
            price: 0.603,
            color: 'black',
            lineWidth: lineWidth,
            lineStyle: 1, // LineStyle.Dotted
            axisLabelVisible: true,
            title: 'ave price',
        };
        const maxPriceLine = {
            price: 0.604,
            color: '#26a69a',
            lineWidth: lineWidth,
            lineStyle: 2, // LineStyle.Dashed
            axisLabelVisible: true,
            title: 'max price',
        };

        candlestickSeries.createPriceLine(minPriceLine);
        candlestickSeries.createPriceLine(avgPriceLine);
        candlestickSeries.createPriceLine(maxPriceLine);

        // Setting the border color for the vertical axis
        chart.priceScale().applyOptions({
            borderColor: '#12A6C0',
        });

        // Setting the border color for the horizontal axis
        chart.timeScale().applyOptions({
            borderColor: '#ACB4AB',
        });

        // simulate real-time data
        function* getNextRealtimeUpdate(realtimeData) {
            for (const dataPoint of realtimeData) {
                yield dataPoint;
            }
            return null;
        }
        //const streamingDataProvider = getNextRealtimeUpdate(data.realtimeUpdates);
        //
        //const intervalID = setInterval(() => {
        //    const update = streamingDataProvider.next();
        //    if (update.done) {
        //        clearInterval(intervalID);
        //        return;
        //    }
        //    series.update(update.value);
        //}, 100);
        // Handle mouse move to adjust the time on the crosshair tooltip
        chart.subscribeCrosshairMove(function (param) {
            const tooltip = document.getElementById('custom-tooltip');
            if (!param || !param.time) {
                tooltip.style.display = 'none'; // Hide tooltip if no time data
                return;
            }

            // Convert to milliseconds and adjust for Bangkok timezone (UTC+7)
            const timestamp = param.time * 1000; // Convert to milliseconds
            const bangkokTime = new Intl.DateTimeFormat('en-US', {
                hour: '2-digit',
                minute: '2-digit',
                hour12: false,
            }).format(new Date(timestamp - (7 * 60 * 60 * 1000))); // Adjust for UTC+7

            // Find the bar corresponding to the current time
            const bar = processedData.find(item => item.time === param.time);

            if (bar) {
                const closePrice = bar.close; //close Get the close price
                const openPrice = bar.open; //close Get the close price

                // Set custom tooltip text with bar time and close price
                tooltip.textContent = `Bar Time: ${bangkokTime} | Close: ${closePrice} Open:${openPrice}`;

                // Optional: Set background color based on bullish or bearish bar
                if (bar.close > bar.open) {
                    tooltip.style.backgroundColor = '#4ab9a4'; // Bullish bar
                } else {
                    tooltip.style.backgroundColor = '#C04444FF'; // Bearish bar
                }

                // Position tooltip near the mouse pointer
                tooltip.style.display = 'block';
                tooltip.style.left = `${param.point.x + 10}px`;
                tooltip.style.top = `${param.point.y + 10}px`;
                tooltip.style.zIndex = '1';
            } else {
                tooltip.style.display = 'none'; // Hide tooltip if no matching bar
            }
        });
        const styles = `
        .buttons-container {
            display: flex;
            flex-direction: row;
            gap: 8px;
        }
        .buttons-container button {
            all: initial;
            font-family: -apple-system, BlinkMacSystemFont, 'Trebuchet MS', Roboto, Ubuntu,
                sans-serif;
            font-size: 16px;
            font-style: normal;
            font-weight: 510;
            line-height: 24px; /* 150% */
            letter-spacing: -0.32px;
            padding: 8px 24px;
            color: rgba(19, 23, 34, 1);
            background-color: rgba(240, 243, 250, 1);
            border-radius: 8px;
            cursor: pointer;
        }
    
        .buttons-container button:hover {
            background-color: rgba(224, 227, 235, 1);
        }
    
        .buttons-container button:active {
            background-color: rgba(209, 212, 220, 1);
        }
    `;

        const stylesElement = document.createElement('style');
        stylesElement.innerHTML = styles;
        container.appendChild(stylesElement);

        const buttonsContainer = document.createElement('div');
        buttonsContainer.classList.add('buttons-container');
        const button = document.createElement('button');
        button.innerText = 'Go to realtime';
        button.addEventListener('click', () => chart.timeScale().scrollToRealTime());
        buttonsContainer.appendChild(button);

        container.appendChild(buttonsContainer);

    </script>


    <!-- TradingView Widget BEGIN -->
    <div class="tradingview-widget-container" style="height:100%;width:100%">
        <div class="tradingview-widget-container__widget" style="height:calc(100% - 32px);width:100%"></div>
        <div class="tradingview-widget-copyright"><a href="https://www.tradingview.com/" rel="noopener nofollow"
                target="_blank"><span class="blue-text">Track all markets on TradingView</span></a></div>
        <script src="https://s3.tradingview.com/external-embedding/embed-widget-advanced-chart.js" async>
            {
                "autosize": true,
                    "symbol": "BINANCE:XRPUSDT",
                        "interval": "1",
                            "timezone": "Asia/Bangkok",
                                "theme": "dark",
                                    "style": "1",
                                        "locale": "en",
                                            "withdateranges": true,
                                                "hide_side_toolbar": false,
                                                    "allow_symbol_change": true,
                                                        "watchlist": [
                                                            "BINANCE:BNBUSDT",
                                                            "BINANCE:XRPUSDT",
                                                            "BINANCE:BTCUSDT"
                                                        ],
                                                            "calendar": false,
                                                                "hide_volume": true,
                                                                    "support_host": "https://www.tradingview.com"
            }
        </script>
    </div>
    <!-- TradingView Widget END -->

</body>

</html>